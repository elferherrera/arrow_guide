<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RecordBatch - Apache Arrow [Rust]</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="arrays.html"><strong aria-hidden="true">2.</strong> Arrays</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="arrays_buffer.html"><strong aria-hidden="true">2.1.</strong> The buffer</a></li><li class="chapter-item expanded "><a href="arrays_data.html"><strong aria-hidden="true">2.2.</strong> Array data</a></li><li class="chapter-item expanded "><a href="arrays_primitive.html"><strong aria-hidden="true">2.3.</strong> Primitive array</a></li><li class="chapter-item expanded "><a href="arrays_nested.html"><strong aria-hidden="true">2.4.</strong> Nested arrays</a></li><li class="chapter-item expanded "><a href="arrays_recordbatch.html" class="active"><strong aria-hidden="true">2.5.</strong> RecordBatch</a></li><li class="chapter-item expanded "><a href="arrays_operations.html"><strong aria-hidden="true">2.6.</strong> Arrow Kernels</a></li></ol></li><li class="chapter-item expanded "><a href="ipc_intro.html"><strong aria-hidden="true">3.</strong> Arrow IPC</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ipc_flatbuffers.html"><strong aria-hidden="true">3.1.</strong> Detour: FlatBuffers</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.2.</strong> Sharing data</div></li></ol></li><li class="chapter-item expanded "><a href="reading_files.html"><strong aria-hidden="true">4.</strong> Reading files</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> Reading CSV files</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> Reading JSON files</div></li><li class="chapter-item expanded "><a href="reading_parquet.html"><strong aria-hidden="true">4.3.</strong> Reading Parquet files</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Arrow Flight</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Setting up a Server</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> DataFusion</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Query data</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Ballista</div></li><li class="spacer"></li><li class="chapter-item expanded "><a href="contributors.html"><strong aria-hidden="true">8.</strong> Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Apache Arrow [Rust]</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#the-recordbatch" id="the-recordbatch">The RecordBatch</a></h1>
<p>A
<a href="https://docs.rs/arrow/3.0.0/arrow/record_batch/struct.RecordBatch.html">RecordBatch</a>
is the last piece of the Arrow crate implementation. It could be said that is
the main goal of the whole Arrow specification; a structure that holds together
data and the metadata that describes it.</p>
<p>Have a look again at the image we saw in the introduction chapter.</p>
<p><img src="images/recordbatch.png" alt="Shared" /></p>
<p>Let us imagine that we are developing a service that, after executing a query,
returns formatted data with the requested information. For this service to be
efficient transferring data, the RecordBatch is an integral piece of the
process. Since each parcel of data contains all the information required to be
read and processed, any process receiving the data that <strong>&quot;speaks&quot;</strong> Arrow can
take the collected data and work on it immediately. There is no cost encoding or
decoding each parcel, it can be worked on it as soon as it is received.</p>
<p>We are going to cover how to transfer data in more detail in the <strong>IPC
chapter</strong>, but for the moment just keep in mind that a RecordBatch is one of the
keys for efficient data transfer.</p>
<h2><a class="header" href="#building-a-recordbatch" id="building-a-recordbatch">Building a RecordBatch</a></h2>
<p>We will begin our exploration into the RecordBatch with an small example. In
this example we are going to create a record that will contain two columns; an
index column and a fruits column. </p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Arc;

use arrow::{
    array::{Int32Array, StringArray},
    datatypes::{DataType, Field, Schema},
    record_batch::RecordBatch,
};

fn main() {
    let schema = Schema::new(vec![
        Field::new(&quot;index&quot;, DataType::Int32, false),
        Field::new(&quot;fruits&quot;, DataType::Utf8, false),
    ]);

    let a = Int32Array::from(vec![1, 2, 3, 4, 5]);
    let b = StringArray::from(vec![&quot;apple&quot;, &quot;banana&quot;, &quot;pineapple&quot;, &quot;melon&quot;, &quot;pear&quot;]);

    let record_batch =
        RecordBatch::try_new(Arc::new(schema), vec![Arc::new(a), Arc::new(b)]).unwrap();

    println!(&quot;{:#?}&quot;, record_batch);
}
</code></pre></pre>
<p>If you run the example you should get something like this:</p>
<pre><code class="language-json">RecordBatch {
    schema: Schema {
        fields: [
            Field {
                name: &quot;index&quot;,
                data_type: Int32,
                nullable: false,
                dict_id: 0,
                dict_is_ordered: false,
                metadata: None,
            },
            Field {
                name: &quot;fruits&quot;,
                data_type: Utf8,
                nullable: false,
                dict_id: 0,
                dict_is_ordered: false,
                metadata: None,
            },
        ],
        metadata: {},
    },
    columns: [
        PrimitiveArray&lt;Int32&gt;
        [
          1,
          2,
          3,
          4,
          5,
        ],
        StringArray
        [
          &quot;apple&quot;,
          &quot;banana&quot;,
          &quot;pineapple&quot;,
          &quot;melon&quot;,
          &quot;pear&quot;,
        ],
    ],
}
</code></pre>
<h3><a class="header" href="#the-schema" id="the-schema">The Schema</a></h3>
<p>Now, let us inspect the pieces we used to create the RecordBatch. The first new
element that we will encounter is going to be the
<a href="https://docs.rs/arrow/3.0.0/arrow/datatypes/struct.Schema.html">Schema</a> struct.</p>
<pre><code class="language-rust ignore">    let schema = Schema::new(vec![
        Field::new(&quot;index&quot;, DataType::Int32, false),
        Field::new(&quot;fruits&quot;, DataType::Utf8, false),
    ]);
</code></pre>
<p>The Schema is used to describe the metadata that our little RecordBatch is going
to hold, and it is going to be our first source of information for the stored
data. Inside the Schema, each column has different properties that make them
unique, e.g. name, data type, etc. In order to encapsulate this information we
need to use the
<a href="https://docs.rs/arrow/3.0.0/arrow/datatypes/struct.Field.html">Field</a> struct.</p>
<p>Each Field in the Schema is responsible for holding the name of the column, the
data type, if the column is nullable, and additional metadata. The Field
metadata can be anything extra that we may want to store and that will be useful
when reading the data from the column.</p>
<p>The Schema struct also has the option to store extra metadata. For example, we
can store the number of rows a column has for future reference, or the name of
the file where the data comes from. Have a look to the next example:</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;
use arrow::datatypes::{DataType, Field, Schema};

fn main() {
    // Creating a schema with metadata
    let field_a = Field::new(&quot;a&quot;, DataType::Int64, false);
    let field_b = Field::new(&quot;b&quot;, DataType::Boolean, false);

    let mut metadata: HashMap&lt;String, String&gt; = HashMap::new();
    metadata.insert(&quot;row_count&quot;.to_string(), &quot;100&quot;.to_string());
    metadata.insert(&quot;file&quot;.to_string(), &quot;example.csv&quot;.to_string());

    let schema = Schema::new_with_metadata(vec![field_a, field_b], metadata);

    println!(&quot;{:#?}&quot;, schema);
}
</code></pre></pre>
<h3><a class="header" href="#the-recordbatch-data" id="the-recordbatch-data">The RecordBatch data</a></h3>
<p>The next piece of the RecordBatch is the data itself. This data comes from Arrow
arrays created using the methods we saw in previous sections.</p>
<pre><code class="language-rust ignore">    let a = Int32Array::from(vec![1, 2, 3, 4, 5]);
    let b = StringArray::from(vec![&quot;apple&quot;, &quot;banana&quot;, &quot;pineapple&quot;, &quot;melon&quot;, &quot;pear&quot;]);

    let record_batch =
        RecordBatch::try_new(Arc::new(schema), vec![Arc::new(a), Arc::new(b)]).unwrap();
</code></pre>
<p>From this snippet we can see that two columns are created using the From trait
implemented for Int32Array and StringArray.</p>
<p>The RecordBatch is finally constructed by passing the defined schema and a
vector of the created data. However, it should be noticed that we are using an
atomic reference (Arc) to the data and not the data itself, making the the
RecordBatch thread safe and the data zero copy. </p>
<h2><a class="header" href="#constructing-from-an-structarray" id="constructing-from-an-structarray">Constructing from an StructArray</a></h2>
<p>Probably those that have just read the previous chapter would have noticed that
a RecordBatch is very similar to an StructArray, and you are right. A
StructArray is a collection of Arrow arrays identified using Field structs. Both
share a similar data structure, and because of this similarity we can construct
a RecordBatch from them.</p>
<p>Have a look at the next code:</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Arc;

use arrow::{
    array::{ArrayRef, BooleanArray, Int32Array, StructArray},
    datatypes::{DataType, Field, Schema},
    record_batch::RecordBatch,
};

fn main() {
    let index = Arc::new(Int32Array::from(vec![0, 1, 2, 3]));
    let boolean_array = Arc::new(BooleanArray::from(vec![false, false, true, true]));
    let int_array = Arc::new(Int32Array::from(vec![42, 28, 19, 31]));

    let struct_array = StructArray::from(vec![
        (
            Field::new(&quot;index&quot;, DataType::Int32, false),
            index as ArrayRef,
        ),
        (
            Field::new(&quot;col_1&quot;, DataType::Int32, false),
            int_array as ArrayRef,
        ),
        (
            Field::new(&quot;col_2&quot;, DataType::Boolean, false),
            boolean_array as ArrayRef,
        ),
    ]);

    let record_batch = RecordBatch::from(&amp;struct_array);
    println!(&quot;{:#?}&quot;, record_batch);
}
</code></pre></pre>
<p>The output should look like this:</p>
<pre><code class="language-json">RecordBatch {
    schema: Schema {
        fields: [
            Field {
                name: &quot;index&quot;,
                data_type: Int32,
                nullable: false,
                dict_id: 0,
                dict_is_ordered: false,
                metadata: None,
            },
            Field {
                name: &quot;col_1&quot;,
                data_type: Int32,
                nullable: false,
                dict_id: 0,
                dict_is_ordered: false,
                metadata: None,
            },
            Field {
                name: &quot;col_2&quot;,
                data_type: Boolean,
                nullable: false,
                dict_id: 0,
                dict_is_ordered: false,
                metadata: None,
            },
        ],
        metadata: {},
    },
    columns: [
        PrimitiveArray&lt;Int32&gt;
        [
          0,
          1,
          2,
          3,
        ],
        PrimitiveArray&lt;Int32&gt;
        [
          42,
          28,
          19,
          31,
        ],
        BooleanArray
        [
          false,
          false,
          true,
          true,
        ],
    ],
}
</code></pre>
<p>As you can see we can construct a RecordBatch easily from the Struct array. This
is because the <strong>From</strong> trait is implemented for the RecordBatch. </p>
<h2><a class="header" href="#nested-structures" id="nested-structures">Nested structures</a></h2>
<p>To finish this section, we are going to see how to create a nested structure
using the tools that can be found within the RecorBatch struct. As you will see
the procedure is fairly straight forward, all we have to do is to define the
StructArray with all its columns and then add it to the schema as it is another
column of the RecordBatch.</p>
<p>The next snippet of code shows an example of how a nested structure could look
by introducing a Struct Array as one of the columns in the RecordBatch. The
resulting RecordBatch will have two columns; one called id and a another called
nested.</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Arc;

use arrow::{
    array::{Array, Float64Array, Int32Array, StringArray, StructArray},
    datatypes::{DataType, Field, Schema},
    record_batch::RecordBatch,
};

fn main() {
    let schema = Schema::new(vec![
        Field::new(&quot;id&quot;, DataType::Int32, false),
        Field::new(
            &quot;nested&quot;,
            DataType::Struct(vec![
                Field::new(&quot;a&quot;, DataType::Utf8, false),
                Field::new(&quot;b&quot;, DataType::Float64, false),
                Field::new(&quot;c&quot;, DataType::Float64, false),
            ]),
            false,
        ),
    ]);

    let id = Int32Array::from(vec![1, 2, 3, 4, 5]);

    let nested = StructArray::from(vec![
        (
            Field::new(&quot;a&quot;, DataType::Utf8, false),
            Arc::new(StringArray::from(vec![&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;])) as Arc&lt;dyn Array&gt;,
        ),
        (
            Field::new(&quot;b&quot;, DataType::Float64, false),
            Arc::new(Float64Array::from(vec![1.1, 2.2, 3.3, 4.4, 5.5])),
        ),
        (
            Field::new(&quot;c&quot;, DataType::Float64, false),
            Arc::new(Float64Array::from(vec![2.2, 3.3, 4.4, 5.5, 6.6])),
        ),
    ]);

    let record_batch =
        RecordBatch::try_new(Arc::new(schema), vec![Arc::new(id), Arc::new(nested)]).unwrap();

    println!(&quot;{:#?}&quot;, record_batch);
}

</code></pre></pre>
<p>After running the previous code you should see something like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>RecordBatch {
    schema: Schema {
        fields: [
            Field {
                name: &quot;id&quot;,
                data_type: Int32,
                nullable: false,
                dict_id: 0,
                dict_is_ordered: false,
                metadata: None,
            },
            Field {
                name: &quot;nested&quot;,
                data_type: Struct(
                    [
                        Field {
                            name: &quot;a&quot;,
                            data_type: Utf8,
                            nullable: false,
                            dict_id: 0,
                            dict_is_ordered: false,
                            metadata: None,
                        },
                        Field {
                            name: &quot;b&quot;,
                            data_type: Float64,
                            nullable: false,
                            dict_id: 0,
                            dict_is_ordered: false,
                            metadata: None,
                        },
                        Field {
                            name: &quot;c&quot;,
                            data_type: Float64,
                            nullable: false,
                            dict_id: 0,
                            dict_is_ordered: false,
                            metadata: None,
                        },
                    ],
                ),
                nullable: false,
                dict_id: 0,
                dict_is_ordered: false,
                metadata: None,
            },
        ],
        metadata: {},
    },
    columns: [
        PrimitiveArray&lt;Int32&gt;
        [
          1,
          2,
          3,
          4,
          5,
        ],
        StructArray
        [
        -- child 0: &quot;a&quot; (Utf8)
        StringArray
        [
          &quot;a&quot;,
          &quot;b&quot;,
          &quot;c&quot;,
          &quot;d&quot;,
          &quot;e&quot;,
        ]
        -- child 1: &quot;b&quot; (Float64)
        PrimitiveArray&lt;Float64&gt;
        [
          1.1,
          2.2,
          3.3,
          4.4,
          5.5,
        ]
        -- child 2: &quot;c&quot; (Float64)
        PrimitiveArray&lt;Float64&gt;
        [
          2.2,
          3.3,
          4.4,
          5.5,
          6.6,
        ]
        ],
    ],
}
<span class="boring">}
</span></code></pre></pre>
<p>As you can see, a RecordBatch is a very powerful structure that will let us put
together the information we want to process or share. We are going to keep using
it for different examples along this book.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="arrays_nested.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="arrays_operations.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="arrays_nested.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="arrays_operations.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
