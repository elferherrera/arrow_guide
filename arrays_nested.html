<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Nested arrays - Apache Arrow [Rust]</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="arrays.html"><strong aria-hidden="true">2.</strong> Arrays</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="arrays_buffer.html"><strong aria-hidden="true">2.1.</strong> The buffer</a></li><li class="chapter-item expanded "><a href="arrays_data.html"><strong aria-hidden="true">2.2.</strong> Array data</a></li><li class="chapter-item expanded "><a href="arrays_primitive.html"><strong aria-hidden="true">2.3.</strong> Primitive array</a></li><li class="chapter-item expanded "><a href="arrays_nested.html" class="active"><strong aria-hidden="true">2.4.</strong> Nested arrays</a></li><li class="chapter-item expanded "><a href="arrays_operations.html"><strong aria-hidden="true">2.5.</strong> Operations with arrays</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Reading files</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.</strong> Reading CSV files</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.2.</strong> Reading JSON files</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.3.</strong> Reading Parquet files</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> IPC and RecordBatch</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> Creating a RecordBatch</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> Detour: FlatBuffers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.3.</strong> Sharing data</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Arrow Flight</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Setting up a Server</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> DataFusion</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Query data</div></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Contributors</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Apache Arrow [Rust]</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#nested-arrays" id="nested-arrays">Nested arrays</a></h1>
<p>A primitive array is a useful struct to store values that have the same
datatype. However, if we only use primitive arrays it will be impossible to
represent complex data structures like datasets.  For this reason nested arrays
were introduced to the Apache Arrow specification, and in the Rust
implementation we have variable size lists, fixed size lists and structs.</p>
<h2><a class="header" href="#variable-size-lists" id="variable-size-lists">Variable size lists</a></h2>
<p>A variable size list is used to represent arrays that are made of variable size
lists. In Rust we have the next containers to create variable size lists:</p>
<ul>
<li>ListArray</li>
<li>StringArray</li>
<li>BinaryArray</li>
<li>LargeListArray</li>
<li>LargeStringArray</li>
<li>LargeBinaryArray</li>
</ul>
<blockquote>
<p><strong>Note</strong>. The difference between the Large and Normal arrays is the type of
datatype offset used to align the space between elemets. In the normal
arrays the offset is represented using  a i32 and in the large list a i64 is
used.</p>
</blockquote>
<blockquote>
<p><strong>Tip</strong>. For more details on how a variable size list is defined and created, it is
recommended that you read this
<a href="https://github.com/apache/arrow/blob/master/docs/source/format/Columnar.rst#variable-size-list-layout">section</a>
of the Arrow columnar format. </p>
</blockquote>
<h3><a class="header" href="#listarray" id="listarray">ListArray</a></h3>
<p>Lets continue this section by creating a
<a href="https://docs.rs/arrow/3.0.0/arrow/array/type.ListArray.html">ListArray</a> to
show you how to create a variable size list and how it is represented in
memory.  For reference, we will use the next image to explain how a ListArray
is created and what is happening behind the scene.</p>
<p><img src="images/list.png" alt="Lists" /></p>
<p>In this example we are going to create a list that is made of three elements.
Each of these elements will me composed of one or more lists. For example,
element <strong>1</strong> will have 2 lists; element <strong>2</strong> will have 2 lists and 1 null;
and element <strong>3</strong> will have one list.</p>
<p>In general we can say that a nested array is made of a master data array and a
series of child data arrays. In the previous image the master array (<strong>a</strong>)
defines the general structure of the array, which in this case it has 3
elements, no nulls and has an offset buffer. The <a href="https://github.com/apache/arrow/blob/master/docs/source/format/Columnar.rst#variable-size-binary-layout">offset
buffer</a>
is used to calculate how many numbers or elements each of the inner lists have. </p>
<p>After the master data array comes the child array (<strong>b</strong>). The child array is
used to define the next nested level in the lists. In this case, the child
array has 6 elements, one null, and offset buffer and a values buffer. By using
this data representation one can nest as many lists as required. You only need
to define a next child and attach it to the ListArray. </p>
<p>With this description in mind, lets create the list array from the image with
the next code:</p>
<pre><pre class="playground"><code class="language-rust">use arrow::buffer::Buffer;
use arrow::array::{ArrayData, ListArray};
use arrow::datatypes::{DataType, Field, ToByteSlice};

fn main() {
    // First we create an ArrayData struct that will hold the values
    // from the array. These values are stored in one buffer aligned and padded.
    let value_data = ArrayData::builder(DataType::Int32)
        .len(10)
        .add_buffer(Buffer::from(&amp;[1, 2, 3, 4, 5, 6, 7, 8, 9, 10].to_byte_slice()))
        .build();

    // Second we define the offsets what will define the lists from the
    // child data(b)
    let value_offsets = Buffer::from(&amp;[0, 2, 4, 7, 7, 8, 10].to_byte_slice());

    // With the values and offset we can define the child data(b). The child
    // data represents the second level in the array. Notice the type for
    // the data array. It is made using the enum DataType::List indicating
    // that its a composite array
    let list_data_type = DataType::List(Box::new(Field::new(&quot;item&quot;, DataType::Int32, false)));
    let list_data = ArrayData::builder(list_data_type)
        .len(6)
        .add_buffer(value_offsets)
        .add_child_data(value_data)
        .null_bit_buffer(Buffer::from([0b00110111]))
        .build();
    
    // The last element is the master data array. This master data
    // array holds all the information required to define the ListArray
    let value_offsets = Buffer::from(&amp;[0, 2, 5, 6].to_byte_slice());
    let list_data_type = DataType::List(Box::new(Field::new(&quot;item&quot;, DataType::Int32, false)));
    let list_data = ArrayData::builder(list_data_type)
        .len(3)
        .add_buffer(value_offsets)
        .add_child_data(list_data)
        .build();

    // If you print the list_data you will only see the combination of 
    // buffers that compose the data array
    println!(&quot;{:?}&quot;, list_data);

    // We need to define a ListArray to be able to understand the composed
    // data that is inside the ListArray
    let list_array = ListArray::from(list_data);
    println!(&quot;{:?}&quot;, list_array);
}
</code></pre></pre>
<p>If you print the previous code you should see something like this (the output
was formated for this book):</p>
<pre><code class="language-json">ListArray [
    ListArray [
        PrimitiveArray&lt;Int32&gt; [ 1, 2, ],
        PrimitiveArray&lt;Int32&gt; [ 3, 4, ],
    ],
    ListArray [
        PrimitiveArray&lt;Int32&gt; [ 5, 6, 7, ],
        null,
        PrimitiveArray&lt;Int32&gt; [ 8, ],
    ],
    ListArray [
        PrimitiveArray&lt;Int32&gt; [ 9, 10, ],
    ],
]
</code></pre>
<p>As you can see, the resulting array is identical to the one described in the
previous image. Notice that by printing the ListArray we are able to see the
real representation of the struct and not the buffers (values represented using
u8).  Behind the scenes the ListArray is doing the steps <strong>(c)</strong> and <strong>(d)</strong>
from the image, which create the nested lists and show that data in the correct
format and structure. </p>
<p>A ListArray is very flexible and by following this procedure is possible to
create any type of nested lists.</p>
<h4><a class="header" href="#using-the-list-builder" id="using-the-list-builder">Using the List builder</a></h4>
<p>In order to make our life easier while creating a List Array we can use the
<a href="https://docs.rs/arrow/3.0.0/arrow/array/type.ListBuilder.html">ListBuilder</a>
and
<a href="https://docs.rs/arrow/3.0.0/arrow/array/type.LargeListBuilder.html">LargeListBuilder</a>.
By using these builders we no longer have to keep track of the three buffers
that compose the List Array. </p>
<p>The next example shows how a list array can be created by just inserting values
into it and selecting when a sub list starts and ends.</p>
<pre><pre class="playground"><code class="language-rust">use arrow::array::{Int32Builder, ListBuilder};

fn main() {
    // List array with builder
    let values_builder = Int32Builder::new(10);
    let mut builder = ListBuilder::new(values_builder);

    //  [[0, 1, 2], [3, 4, 5], [6, 7]]
    builder.values().append_value(0).unwrap();
    builder.values().append_value(1).unwrap();
    builder.values().append_value(2).unwrap();
    builder.append(true).unwrap();
    builder.values().append_value(3).unwrap();
    builder.values().append_value(4).unwrap();
    builder.values().append_value(5).unwrap();
    builder.append(true).unwrap();
    builder.values().append_value(6).unwrap();
    builder.values().append_value(7).unwrap();
    builder.append(true).unwrap();
    let list_array = builder.finish();

    println!(&quot;{:?}&quot;, list_array);
}
</code></pre></pre>
<h3><a class="header" href="#stringarray" id="stringarray">StringArray</a></h3>
<p>An String Array
(<a href="https://docs.rs/arrow/3.0.0/arrow/array/type.StringArray.html">StringArray</a>
and
<a href="https://docs.rs/arrow/3.0.0/arrow/array/type.LargeStringArray.html">LargeStringArray</a>)
is used to represent a list of strings stored using the arrow format. A
StringArray follows the same idea as a ListArray, the only difference is that
the values buffer is made of <strong>u8</strong>s that represents the letters or characters.</p>
<p>As an example lets create an StringArray that holds the next list:</p>
<pre><code class="language-json">array = [&quot;Hello&quot;, &quot;from&quot;, null, &quot;Apache&quot;, &quot;Arrow&quot;]
</code></pre>
<pre><pre class="playground"><code class="language-rust">use arrow::buffer::Buffer;
use arrow::array::{ArrayData, StringArray};
use arrow::datatypes::{DataType, ToByteSlice};

fn main() {
    // First we define the values that will represent the letters 
    // from the array
    let values: [u8; 20] = [
        b'h', b'e', b'l', b'l', b'o', b'f', b'r', b'o', b'm', 
        b'A', b'p', b'a', b'c', b'h', b'e', b'A', b'r', b'r', b'o', b'w', 
    ];

    // And the offset that represents how many characters are in each word
    let offsets: [i32; 6] = [0, 5, 9, 9, 15, 20];

    // By the way, notice the order each buffer is added to the ArrayData.
    // Each buffer is stored in a vector of buffers, so the only reference 
    // other constructors will have is the vector index.
    let array_data = ArrayData::builder(DataType::Utf8)
        .len(5)
        .add_buffer(Buffer::from(offsets.to_byte_slice()))
        .add_buffer(Buffer::from(&amp;values[..]))
        .null_bit_buffer(Buffer::from([0b00011011]))
        .build();
    let string_array = StringArray::from(array_data);

    println!(&quot;{:?}&quot;, string_array);
    println!(&quot;Value: {:?}&quot;, string_array.value(0));
    println!(&quot;Value: {:?}&quot;, string_array.value(1));
    println!(&quot;Value: {:?}&quot;, string_array.value(2));
}
</code></pre></pre>
<p>Your output should look similar to this:</p>
<pre><code class="language-json">StringArray
    [ &quot;hello&quot;, &quot;from&quot;, null, &quot;Apache&quot;, &quot;Arrow&quot;, ]
</code></pre>
<p>Notice how when we print the string array the strings are printed as the should
be and not as the u8 values stored in the buffer. This is thanks to the fact
that a StringArray &quot;knows&quot; the type of data it holds and thus can represent the
strings in the correct way. This can also be seen when the value() method is
used on the string. The returned value is the correct representation of the word
stored in the array.</p>
<blockquote>
<p><strong>Tip</strong>. From your code remove the null_bit_buffer method from the
constructor and see how the empty space is now represented.</p>
</blockquote>
<h4><a class="header" href="#using-the-string-builder" id="using-the-string-builder">Using the String builder</a></h4>
<p>Similar to the List Array, the construction of a String Array can become a bit
complicated if we do it from scratch. You would have to split and put together
all the letters from the list and then you would need to create an offset list
for the words, plus adding the validity buffer. This would take a lot of time
every time a new string array is required. For this reason, the
<a href="https://docs.rs/arrow/3.0.0/arrow/array/type.StringBuilder.html">StringBuilder</a>
and
<a href="https://docs.rs/arrow/3.0.0/arrow/array/type.LargeStringBuilder.html">LargeStringBuilder</a>
where created.</p>
<p>Lets create a new String Array using an String Builder.</p>
<pre><pre class="playground"><code class="language-rust">use arrow::array::StringBuilder;

fn main() {
    println!(&quot;Creating an String Array using builder&quot;);

    let mut builder = StringBuilder::new(10);
    builder.append_value(&quot;one&quot;).unwrap();
    builder.append_value(&quot;two&quot;).unwrap();
    builder.append_value(&quot;three&quot;).unwrap();
    builder.append_null().unwrap();
    builder.append_value(&quot;four&quot;).unwrap();

    let string_array = builder.finish();
    println!(&quot;{:?}&quot;, string_array);
}
</code></pre></pre>
<p>As you can see, the creation process is more streamlined an it feels more
natural. The builder will append the string and it will create the required
buffers automatically.</p>
<h2><a class="header" href="#struct-array" id="struct-array">Struct Array</a></h2>
<p><a href="https://docs.rs/arrow/3.0.0/arrow/array/struct.StructArray.html">StructArrays</a>
are used to represent mixed data, each being identified by a name and a
datatype.  As an example we have this array:</p>
<pre><code class="language-json">array = {
    &quot;a&quot;: [false, null, null, null, true],
    &quot;b&quot;: [null, 28, 42, null, null],
    &quot;c&quot;: [1, 2, 3, 4, 5]
}
</code></pre>
<p>As it can be seen, each element in the array is represented by a tuple made of
a name and an array of values. To construct an struct you will need to define
the data that represents each of the fields. In the next node we will construct
the previous array using the ArrayData builders we have been using.</p>
<pre><pre class="playground"><code class="language-rust">use arrow::buffer::Buffer;
use arrow::array::{ArrayData, StructArray};
use arrow::datatypes::{DataType, Field, ToByteSlice};

fn main() {
    // First we create all the base data that represents each of the elements
    // in the struct
    let boolean_data = ArrayData::builder(DataType::Boolean)
        .len(5)
        .add_buffer(Buffer::from([0b00010000]))
        .null_bit_buffer(Buffer::from([0b00010001]))
        .build();

    let int_data_b = ArrayData::builder(DataType::Int32)
        .len(5)
        .add_buffer(Buffer::from([0, 28, 42, 0, 0].to_byte_slice()))
        .null_bit_buffer(Buffer::from([0b00000110]))
        .build();

    let int_data_c = ArrayData::builder(DataType::Int32)
        .len(5)
        .add_buffer(Buffer::from([1, 2, 3, 4, 5].to_byte_slice()))
        .null_bit_buffer(Buffer::from([0b00011111]))
        .build();

    // The field types are used to indicate the type of data that each element
    // in the structarray has
    let mut field_types = vec![];
    field_types.push(Field::new(&quot;a&quot;, DataType::Boolean, false));
    field_types.push(Field::new(&quot;b&quot;, DataType::Int32, false));
    field_types.push(Field::new(&quot;c&quot;, DataType::Int32, false));

    let struct_array_data = ArrayData::builder(DataType::Struct(field_types))
        .len(5)
        .add_child_data(boolean_data.clone())
        .add_child_data(int_data_b.clone())
        .add_child_data(int_data_c.clone())
        .build();

    let struct_array = StructArray::from(struct_array_data);

    println!(&quot;{:?}&quot;, struct_array);
}
</code></pre></pre>
<p>The output from the code should look like this:</p>
<pre><code class="language-json">StructArray [
    -- child 0: &quot;a&quot; (Boolean)
    PrimitiveArray&lt;Boolean&gt; [ false, null, null, null, true, ]
    -- child 1: &quot;b&quot; (Int32)
    PrimitiveArray&lt;Int32&gt; [ null, 28, 42, null, null, ]
    -- child 2: &quot;c&quot; (Int32)
    PrimitiveArray&lt;Int32&gt; [ 1, 2, 3, 4, 5, ]
]
</code></pre>
<p>StructArrays can also be constructed using the StructArray::from helper, which
takes the underlying arrays and field types. In the next example we will
construct this struct using the From trait.</p>
<pre><code class="language-json">array = {
    &quot;b&quot;: [false, false, true, true],
    &quot;c&quot;: [42, 28, 19, 31]
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">use arrow::array::{Array, BooleanArray, Int32Array, StructArray};
use arrow::datatypes::{DataType, Field};

use std::sync::Arc;

fn main() {
    let struct_array = StructArray::from(vec![
        (
            Field::new(&quot;b&quot;, DataType::Boolean, false),
            Arc::new(BooleanArray::from(vec![false, false, true, true])) as Arc&lt;dyn Array&gt;,
        ),
        (
            Field::new(&quot;c&quot;, DataType::Int32, false),
            Arc::new(Int32Array::from(vec![42, 28, 19, 31])),
        ),
    ]);

    println!(&quot;{:?}&quot;, struct_array);
}
</code></pre></pre>
<p>The output should look like this:</p>
<pre><code class="language-json">StructArray [
    -- child 0: &quot;b&quot; (Boolean)
    PrimitiveArray&lt;Boolean&gt; [ false, false, true, true, ]
    -- child 1: &quot;c&quot; (Int32)
    PrimitiveArray&lt;Int32&gt; [ 42, 28, 19, 31, ]
]
</code></pre>
<p>So, from these examples you can see that a struct is the perfect candidate to
represent in memory a dataframe. These dataframes can be shared, without
copying the data, among processes in order to read and process the data. You
could read a file and create a StructArray, and then pass a reference of such
array to another process for further analysis. And since all data is following
a columnar format, the dataframe is stored in memory in a very efficient way.</p>
<p>In the next chapter we are going to talk about the RecordBatch and how it can 
be used to share data between processes.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="arrays_primitive.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="arrays_operations.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="arrays_primitive.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="arrays_operations.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
